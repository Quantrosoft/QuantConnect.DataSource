/*
 * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
 * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

using QuantConnect.Data;
using QuantConnect.Data.Consolidators;
using QuantConnect.Data.Market;
using QuantConnect.DataSource;
using QuantConnect.Logging;
using QuantConnect.Util;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;

namespace QuantConnect.Lean.DataSource.Dukascopy
{
    /// <summary>
    /// Data downloader class for pulling data from Data Provider
    /// </summary>
    public class DukascopyDataDownloader : IDataDownloader, IDisposable
    {
        enum Id
        {
            market,
            symbol,
            type,
            description,
            quote_currency,
            contract_multiplier,
            minimum_price_variation,
            lot_size,
            market_ticker,
            minimum_order_size,
            price_magnifier,
            strike_multiplier
        }

        /// <inheritdoc cref="DukascopyDataProvider"/>
        private readonly DukascopyDataProvider mDukascopyDataProvider;

        /// <summary>
        /// Initializes a new instance of the <see cref="DukascopyDataDownloader"/>
        /// </summary>
        public DukascopyDataDownloader()
        {
            mDukascopyDataProvider = new DukascopyDataProvider();
        }

        /// <summary>
        /// Get historical data enumerable for a single dcSymbol, type and resolution given this start and end time (in UTC).
        /// </summary>
        /// <param name="parameters">Parameters for the historical data request</param>
        /// <returns>Enumerable of base data for this dcSymbol</returns>
        /// <exception cref="NotImplementedException"></exception>
        public IEnumerable<BaseData> Get(DataDownloaderGetParameters parameters)
        {
            // Define a list to store QuoteBar instances
            List<Tick> tickList = null;
            var error = "";

            if (parameters.Resolution == Resolution.Tick)
                tickList = new List<Tick>();
            else
            {
                error = $"DukascopyDataDownloader only can provide Ticks.Minutes, hours and day bars will be generated by downloader";
                Log.Error(error);
                //throw new Exception(error); // Re-throw if the algorithm cannot continue
                return null;
            }

            var symbolPropertiesPath = Path.Combine(Globals.DataFolder, "symbol-properties", "symbol-properties-database.csv");
            if (!File.Exists(symbolPropertiesPath))
            {
                error = $"{symbolPropertiesPath} does not exist";
                Log.Error(error);
                //throw new Exception(error); // Re-throw if the algorithm cannot continue
                return null;
            }

            var symbolTicksPath = Path.Combine(Globals.DataFolder,
                parameters.Symbol.SecurityType.ToLower(),
                "dukascopy",
                parameters.Resolution.ToLower(),
                parameters.Symbol.Value.ToLower());

            string[] columns = null;
            using (var reader = new StreamReader(symbolPropertiesPath))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    // Split the line into columns (assuming comma-separated values)
                    columns = line.Split(',');

                    // Ensure the line has at least two columns to avoid index errors
                    if (columns[0].Trim() == "dukascopy" && columns[1].Trim() == parameters.Symbol.Value)
                        break;
                }
            }

            if (null == columns)
            {
                error = $"{parameters.Symbol.Value} does not exist in {symbolPropertiesPath}";
                Log.Error(error);
                //throw new Exception(error); // Re-throw if the algorithm cannot continue
                return null;
            }

            // get ticksize from pipsize by dividing by 10
            var ticksize = decimal.Parse(columns[(int)Id.minimum_price_variation], CultureInfo.InvariantCulture) / 10;
            var digits = (int)Math.Log10(1.0 / (double)ticksize);

            // get symbol name for Dukascopy web site access
            var dcSymbol = columns[(int)Id.market_ticker].Trim();

            // Try to get quote at requested datetime 
            error = DukascopyRaw.GetNextQuote(parameters.StartUtc,
                dcSymbol,
                out DateTime time,
                out uint ask,
                out uint bid,
                out float askVolume,
                out float bidVolume,
                out bool isFirstTickOfHour,
                out bool isLastTickOfHour);

            // if requested quote does not exist try to find earliest entry
            if ("" != error)
            {
                error = DukascopyRaw.FindFirst(dcSymbol, out time);
                if ("" != error)
                {
                    Log.Error($"{error}");
                    throw new Exception(error);
                }
            }

            DukascopyRaw.ResetCurrentHour();

            // Populate the list with QuoteBars
            for (DateTime dt = time; ;)
            {
                // 20241219_quote.zip
                var path = Path.Combine(symbolTicksPath, dt.ToString("yyyyMMdd") + "_quote.zip");
                if (null != tickList && File.Exists(path))
                {
                    dt += TimeSpan.FromHours(23);
                    isLastTickOfHour = true;
                }
                else
                {
                    error = DukascopyRaw.GetNextQuote(
                        dt,
                        dcSymbol,
                        out time,
                        out ask,
                        out bid,
                        out askVolume,
                        out bidVolume,
                        out isFirstTickOfHour,
                        out isLastTickOfHour);

                    // Add to the list
                    // DateTime time, Symbol symbol, decimal bid, decimal ask
                    if (0 != bid)
                    {
                        var tick = new Tick(
                            time,
                            parameters.Symbol,
                            bid * ticksize,
                            ask * ticksize
                        );
                        tickList.Add(tick);

                        if (isFirstTickOfHour)
                            Console.WriteLine(parameters.Symbol.Value + ": " + dt.ToString()
                                + ", " + tick.BidPrice.ToString($"F{digits}", CultureInfo.InvariantCulture)
                                + ", " + tick.AskPrice.ToString($"F{digits}", CultureInfo.InvariantCulture));
                    }
                }

                if (isLastTickOfHour)
                {
                    dt += TimeSpan.FromHours(1);
                    if (dt >= parameters.EndUtc || dt.Date >= DateTime.Now.Date)
                        break;
                }
            }

            return tickList;
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            mDukascopyDataProvider?.DisposeSafely();
        }
    }
}
